syms x y; %定义符号变量
K = [4 x 8 y;12 1 6 9;3 6 4 6;2 11 3 8]; %输入密钥矩阵K
det_K = det(K) %计算K的行列式

syms t; %定义符号变量
Q = [1 1;1 0]*[1 1;1 0]*[3 1;1 0]*[1 1;1 0]*[1 1;1 0]*[3 1;1 0]*[3 1;1 0]
91
S = [187;105]
Q*[1;0] %验证矩阵S是否与其相等
Q_inv = inv(Q) %Q的逆矩阵
uv0 = [-761*Q_inv(1,2) -761*Q_inv(1,1)] %方程（5-14）的一个特解
gs = gcd(S(1),S(2)); %最大公约数
u = uv0(1)-S(1)/gs*t; %u的通解
v = uv0(2)+S(2)/gs*t; %v的通解
u0 = uv0(1)-S(1)/gs*(-232);
v0 = uv0(2)+S(2)/gs*(-232);
x0 = u0 %x的一个非负整数特解
y0 = -v0 %y的一个非负整数特解

M = [1 13 19 8 1;3 16 8 5 19;3 12 0 0 11;15 9 20 20 27]; %明文矩阵
K1 = [4 7 8 8;12 1 6 9;3 6 4 6;2 11 3 8]; %密码矩阵
det(K1) %验证密码矩阵是否可逆
C = mod(K1 * M,28) %密文
K1_inv = inv(K1);
K1_inv = round(K1_inv); %以整数形式参与运算
K2 = mod(K1_inv,28) %解密的钥匙
M = mod(K2 * C,28) %恢复明文

n=3;
A =rand(n,n);
s=zeros(n,1);
for i=1:n
for j=1:n
s(i)=s(i)+A(i,j);
end
end
for i=1:n
for j=1:n
A(i,j)=A(i,j)/s(i);
end
end
det(A)

K=[12 16 5;8 3 5;7 9 3];
det_K = det(K)

M=[13,18,27,8,9,12,12,27;
13,1,4,5,27,20,8,9;
19,27,3,15,4,5,28,27;
]
K1=[12 16 5; 8 3 5; 7 9 3];
det(K1) %验证密码矩阵是否可逆
C = mod(K1 * M,28) %密文
K1_inv = inv(K1);
K1_inv = round(K1_inv); %以整数形式参与运算
K2 = mod(K1_inv,28) %解密的钥匙
M = mod(K2 * C,28) %恢复明文
